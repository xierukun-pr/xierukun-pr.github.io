## HTML5+CSS3

### 一、前言

> HTML5 和 CSS3，分别指 HTML 的第五代版本标准 和 CSS 的第三代版本标准。
>
> 两者都是当前正在使用的最新版本 标准。
>
> 被推出的目的，肯定都是为了适应时代的发展，科技的进步，补充一些针对性的内容。

### 二、HTML5

**HTML5 主要新增的内容：**

- 新的语义化标签。如：`<header>` 和 `<section>`
- 新增用于 2D 绘图的 `<canvas>` 元素
- 新增本地存储方案（也称 web 存储对象）：`localStorage`  和  `sessionStorage`，以键对值得形式，存储字符串内容。
- 新增新的表单控件：如日历、日期和时间
- 新增获取用户地理位置的 api，可以检索用户所使用设备得当前地理位置
- 针对移动端，新增得新媒体功能。`video`  和 `audio`
- 针对用户体验，新增 应用缓存（AppCache)，可以使用户离线浏览。
- 针对性能体验，新增 Web Worker，相当于 主线程之外的多余线程。 
- 针对网络编程（客户端和服务端的轮询方案），新增 WebSocket ，全双工通讯协议。

> **可以发现，HTML5 版本新增的内容，不仅涉及了标签，还涉及一些功能API，这是其实是 W3C 组织进步的表现吧，作为开发者可以在不使用脚本的情况下，也能实现一些简单的功能。**

### 三、CSS3 

**css3 主要新增的内容：**

- **说起 css3，跟CSS2 对比，真的是小巫见大巫。**
- 首先，CSS3 给我们新增了很多元素选择器，你比如，属性选择器 和 结构伪类选择器。
- 然后，针对边框，新增了，圆角边框、边框阴影、边界图片。
- 针对 背景：背景图片、背景大小、背景裁切
- 针对花里胡哨：新增了渐变效果（线性渐变、径向渐变）、新增了文本效果（文本阴影、文本溢出）、新增了自定义字体
- 针对动画：新增了2D、3D旋转效果（可以对元素拉长、移动和缩放），新增了过渡效果 和 关键帧动画（flash 是逐帧动画 和补间动画。），关键帧动画其实也是类似的吧，先定义逐帧效果，然后再 animation 中，代入时间轨道。

- 除了刚才提到的这些内容外，CSS3 还有一个比较重要的概念，那就是 盒模型，关于元素宽高是否包含内边距边框。
- 还有就是，弹性盒子。给最外层元素指定 `display:flex`，元素就变成了弹性盒子，可以指定直接子元素的布局方式，摆放位置合间距，既方便，又省了一些代码。

### 四、Flex

**关于 flex ，其实现在网页布局基本上都离不开他。我简单说下，他几个重要的属性吧：**

- `flex-direction` : 指定项目的主轴方向，从左到右还是从右到左，从上到下，从下到上
- `flex-wrap` :  定义项目怎么换行。
- `justify-content` ： 定义项目在主轴上的对齐方式（左中右）
- `align-items`：定义项目在交叉轴怎么对齐。（上中下。）
- `align-content`: 定义多条轴线对齐方式。（左上，坐下，两端对齐）

- 刚才讲的是定义项目的，项目自身，也可通过属性来，调整排列顺序、容器空间大小、对齐方式等等。

### 五、水平垂直居中

- position定位（只适用于子盒子有宽度和高度的时候）
- position+transform（子盒子有或没有宽高的时候都适用）
- flex布局（弹性布局）（子盒子有或没有宽高的时候都适用）

![image-20210428222923625](index.assets/image-20210428222923625.png)



![image-20210428222932956](index.assets/image-20210428222932956.png)

![image-20210428222945295](index.assets/image-20210428222945295.png)》》



### 六、其他重要

**1、清除浮动：** 标签法和指定高度都不推荐，终极方案，伪元素或双伪元素清除浮动。

**2、BFC 特性:**  通俗一点来讲，可以把 BFC 理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。

**只要元素满足下面任一条件即可触发 BFC 特性：**

- body 根元素
- 浮动元素：float 除 none 以外的值
- 绝对定位元素：position (absolute、fixed)
- display 为 inline-block、table-cells、flex
- overflow 除了 visible 以外的值 (hidden、auto、scroll)

**3、事件冒泡：** 点击元素，会优先查找自己身上，有没有绑定相关事件方法。如果没有，则直接往上级元素查找。如果上级有绑定，当你点击子元素的时候，就会触发上级身上绑定的事件。

使用 函数 内置参数 `event` 身上的方法，来组织事件冒泡。

```js
function (event) {
    event.stopPropagation();
}
```





## 闭包

### 一、前言

> **说起，闭包，什么是闭包？**
>
> 可以联系生活来理解，把书放进书包 ，把笔放进文具盒。这样形成密闭的隔离环境，不会受到外界干扰，这就是闭包。
>
> **再结合我们前端知识来说下我的理解**：
>
> 在生活中我们需要保护起来的东西，可以把它看成是一个对象，一个具有功能特性的对象，保护这个功能不会受到外界的影响。
>
> 在 程序的世界里，函数是一等公民，我们通过函数，来抽象的描述现实需求功能的工具。所以我们说到的闭包，其实也就是如何保护函数和函数里面的东西，或者说状态。
>
> **从前端开发者的角度，来考虑闭包的问题，势必跟执行上下文 和 作用域链，这两个知识点有关。所以考察闭包，也是同时考察这两个知识点。**

### 二、执行上下文

> **什么是执行上下文？**
>
> 这个概念有点抽象，按照咱们中国话来讲，执行上下文其实就是，当前 JavaScript 代码被解析和执行时所在环境。
>
> 又因为 JavaScript 代码在运行过程中，会为某些特定的变量、函数和对象，划定访问原则。这就产生了，全局作用域和局部作用域的说法。
>
> 所以这个执行上下文，也被分为：全局执行上下文、 函数执行上下文 以及 EVal 函数执行上下文。然后，又因为这个 Eval 函数上下文，很多资料都说，跟内存有关，慎用，前端也不咋用，所以此次面试，忽略不计。
>
> **全局执行上下文：**
>
> 全局执行上下文最基础的执行上下文，不在函数里面的代码，都位于全局上下文中。在全局上下文中主要做两件事：（1）创建全局对象，在浏览器中就是 window （2）将 this 指向这个全局对象。一个程序只能有一个全局执行上下文。
>
> **函数执行上下文：**
>
> 每次调用改函数时，都会为该函数创建一个新的执行上下文。每个函数都有自己的执行上下文，但是只有在函数被调用时，才会创建。一个程序可以有，可以有任意数量的执行上下文。
>
> **总的概况，执行上下文包括三个生命周期：创建阶段、执行阶段、回收阶段。**
>
> **创建阶段主要内容是：** 
>
> - 创建变量对象
> - 创建作用域链
> - 确定 this 执行，运行时绑定 this
>
> **执行阶段：** 执行变量赋值，执行代码
>
> **回收阶段：** 上下文出栈，等待引擎回收执行上下文

### 三、执行上下文栈

见上我们可知，函数多了，就有多个执行上下文，每次调用函数创建一个新的执行上下文。

那么， JavaScript 引擎是如何管理创建这么多执行上下文的呢？

> JavaScript 引擎 创建了执行上下文栈来管理执行上下文。
>
> **可以把执行上下文栈认为是一个存储函数调用栈的结构，遵循先进后出的原则**
>
> ![img](https://image.fundebug.com/2019-03-19-02.gif)
>
> 从上面的流程图，我们需要记住以下几个关键点：
>
> - JavaScript 执行在单线程上，所有的代码都是排队执行。
> - 一开始浏览器执行全局的代码时，首先会创建全局的执行上下文，压入执行栈顶部。
> - 每当进入一个函数的执行就会创建函数的执行上下文，并且把它压入执行栈的顶部。当前函数执行完成后，当前函数的执行上下文出栈，并等待垃圾回收。
> - 浏览器的 JS 执行引擎总是访问栈顶的执行上下文。
> - 全局上下文只有唯一的一个，它在浏览器关闭时出栈。
>
> **我们再看下面的栗子，帮助理解下：**
>
> ```js
> var color = 'blue';
> function changeColor() {
>     var anotherColor = 'red';
>     function swapColors() {
>         var tempColor = anotherColor;
>         anotherColor = color;
>         color = tempColor;
>     }
>     swapColors();
> }
> changeColor();
> ```
>
> 上述代码的运行按照如下步骤：
>
> - 当上述代码在浏览器加载时，JavaScript 引擎会创建一个全局执行上下文并且将它推入当前的执行栈
> - 调用 changeColor 函数时，此时 changeColor 函数内部代码还未执行，JS 执行引擎立即创建一个 changeColor 的执行上下文（简称 EC），然后把这执行上下文压入到执行栈（简称 ECStack）中。
> - 执行 changeColor 函数过程中，调用 swapColors 函数，同样地，swapColors 函数执行之前也创建一个 swaoColors 的执行上下文，并压入到执行栈中。
> - swapColors 函数执行完成，swapColors 函数的执行上下文出栈，并且被销毁。
> - changeColors 函数被执行完成，changeColor 函数的执行上下文出栈，并且被销毁。
>
> ![img](https://image.fundebug.com/2019-03-19-03.png)



### 四、总结闭包

**（1）闭包是将函数内部和函数外部连接起来的桥梁**

**（2）闭包发生在函数内部，目的是保护某些变量，不会被外界干扰或引用**

**（3）闭包是利用了执行上下文和作用域链，即：函数内部可以访问函数外部，但是函数外部缺不能访问函数内部的变量（状态）**

**（4）常见的闭包，有下面两种情况。**



### 五、常见闭包两种情况

> **以下两种情况的示例，都是通过判断 a 的 console 值来 理解作用域这一概念。**

**（1）函数作为返回值**

```js
function test() {
    const a = 1;
    return function() {
        console.log('a', a);
    }
}

const fn = test();
const a = 2;
fn();   // 我们判断 test 函数里面的 console.log 语句打印的是哪个a
```

**（2）函数作为参数**

```js
function test(fn) {
    const a = 1;
    fn();
}

const a = 2;
function fn() {
    console.log('a',a);
}
test(fn); 

// 注意，这个示例，这里 console.log('a',a) => 'a',2
// a 的取值是2，所以你要知道，函数的声明和调用是分开的
// 被调用函数的状态，优先在当前声明函数的作用域查找
```



## 异步方案

### 一、Event Loop

> **事件循环是 JS 基础最为重要的知识点之一，我们需要认真的理解 **

- **创建一段代码**

```js
  /* 我们知道，JS 引擎解析执行代码是 自上而下的 */
   console.log('xierukun.com');
   
   setTimeout(function callback(){
       console.log('我是一个异步回调函数！');
   }, 3000);

   console.log('xierukun.cn');
```

- **代码被解析、执行的过程是：Js 预处理器将 全局执行上下文的代码，放入全局执行上下文栈，代码被解析 => JS引擎自上而下，将每个执行语句，加载到 `call Stack` 调用栈中 执行代码 => 一般情况下，同步语句会直接被执行掉，并清空调用栈 => 如果遇到异步代码，例如 定时器，会将其暂时放入浏览器的 webAPIs 线程中管理，等待同步代码都指向完毕后 => JS引擎再去访问 WebAPIS 线程，获取到相关定时任务结束的代码。  **

- **参照下面这幅图进行理解：**

![image-20210506190226903](index.assets/image-20210506190226903.png)

- **首先第一行代码，已经被执行掉了，直接在控制台打印输出 => 第二行代码，注意，所有异步操作的声明，都是同步的 ，所以也是先加载到调用栈中 => 第二行代码被放入调用栈执行，判断为异步操作，放入 webApIs 线程中 => JS 引擎接着往下执行，第三条语句**

![image-20210506205908609](index.assets/image-20210506205908609.png)

- **在浏览器 Web APIs 的定时器管理模块中，3s 后，会将回调函数，放入到 `Callback Queue` 中**

![image-20210506213323822](index.assets/image-20210506213323822.png)



- **<font color="red">Event Loop</font> 的状态是一直在轮询 Callback Queue 的**

![Event Loop](index.assets/Event%20Loop.gif)



- **当 <font color="red">Event Loop</font> 轮询到 Callback Queue 中有记录，则把回调函数推到调用栈中执行 **

![666](index.assets/666.gif)

### 二、宏任务和微任务

> 在上面我们讲到 了 Event Loop (事件循环)，我们先来梳理下，大概流程：
>
> - 当 JS 引擎开始解析我们的代码时，可以分为两个阶段，预编译阶段 和执行阶段。
> - 预编译阶段的主要动作是，创建上下文执行栈，也就是代码执行环境。主要工作是，创建变量对象，创建全局对象，把this 指向全局对象。
> - 执行阶段，把代码从全局上下文执行栈中，一个表达式一个表达式，加载到 调用栈中执行。（中国人都知道 JS 是单线程，也就是只有一个调用栈），在执行阶段，如果遇到是异步的对象，比如定时器，则将该段回调函数，放置浏览器 webAPIs 模块中管理。（详见上面几幅图）
> - **异步操作最终会放到任务队列中，排队等待重新进入主线程（调用栈）被执行掉。而这个异步的任务队列，也被分成宏任务队列 和 微任务队列。**

**！！！ 微任务队列 会在 宏任务队列 之前被执行。只有微任务队列被清空，才会去访问 宏任务。**

**常见宏任务：**

- **新程序或子程序被直接执行**
- **事件的回调函数**
- **setTimeout() 和 setInterval()**

**常见的微任务有：**

- **Promise.then() .catch() . finally()**
- **MutationObserver**
- **Object.observe**

**注意的是：微任务虽然调用的优先级大于宏任务，但是异步任务队列的起点在宏任务。执行完一次宏任务后，下一次必须执行清空完微任务队列。值得注意的是：新程序也被归为宏任务，大致流程如下：**

**清空同步任务 => 宏任务（script 标签）=> 微任务清空=>宏任务=> 是否还有微任务**

 

### 一、使用 Promise 加载图片

> **在了解前端都有哪些常见的异步方案之前，我们先了解下，现在比较成熟的异步方法案例**

```js
function loadImage(src) {
    const promise = new Promise ((resolve,reject) => {
        const img = document.createElement('img');
        img.onload = function() {
            resolve(img);
        }
        img.onerror = function() {
            const error = new Error('图片加载失败，url为 ${url}')
            reject();
        }
        img.src = src;
    });
    
    reurn promise;
}

const url1 = 'https://xierukun.com/images/user.png'
loadImage(url1).then(img => {
    console.log('img', img)
}).catch(e =>{
    console.log('error', e);
})
```





### 三、Promise 的三种状态

> Promise 是 ES6 新增 最为广泛应用的异步方案。
>
> 在学习使用 Promise 时，我们需要了解到 它的一些概念。
>
> **（1）Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了`Promise`对象。**
>
> **（2）所谓`Promise`，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。**

**`Promise`对象有以下两个特点：**

- **对象的状态不受外界影响。**Promise 对象代表一个异步操作，有三种状态：`pending` （进行中）、`fulfilled` （已成功）和 `rejected`（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是 promise 这个名字的由来，它的英语意思是 “承诺”，表示其他手段无法改变。
- **一旦状态改变，就不会再变，任何时候都可以得到这个结果。** `Promise` 对象的状态改变，只有两种可能：从 进行中（`pending`） 变为成功（`fulfilled`） 或者 从进行中（`pending` ） 变成 失败（`rejected`）。只要这两种情况发生，状态就凝固了，不会再变，会一直保持这个结果，这时就称为 `resolved` （已定型）。如果改变已经发生了，你再对 `Promise` 对象添加回调函数，也会立即得到这个结果。

```js
const promise = new Promise(function(resolve,reject) { // 成功 or 失败 的两种状态
    
    // 注意了，创建 promise 时，这里的表达式为同步代码 
    
    if (/* 异步操作成功 */) {
       resolve(value)  
    } esle {
        reject(error);
    }
})
```

















## 深浅拷贝

### 一、为什么需要深浅拷贝

> **在我们生活当中：**
>
> 如果需要修改一个重要文件，一般情况下，防止出错，我们会对重要文件进行拷贝，作为留底参照，避免损坏文件原有的重要信息。
>
> **在我们实际工作当中：**
>
> 如果需要两个或多个初始值相同的变量，在发生修改后互不干扰，这时候，我们也需要拷贝。
>
> **再简单理解下，深浅拷贝其实就是：**
>
> **我们拷贝一个初始变量，得到一个或多个同值得初始化变量。**
>
> **如果其中一个变量值发生改变，影响到其它变量值，此时拷贝的类型，属于浅拷贝，拷贝的是引用关系，相当于拷贝指针。**
>
> **如果其中一个变量值发生改变，并没有影响到其它变量值的修改，此时拷贝的类型，属于深拷贝，相当于复制整个初始变量值。与初始变量，完全属于两个物种。**

### 二、栈空间 和堆空间

> **考察拷贝的知识点，其实也主要涉及到了内存空间的知识点吧：**
>
> 在 JavaScript 这门语言当中，内存空间的调度和使用，又和 三种数据结构有关。
>
> **分别是：栈（stack）、堆（heap）以及队列（queue）**
>
> 联系到 JavaScript 这些数据结构相关的专业名词，咱们也如雷贯耳
>
> **上下文执行栈、保存复杂数据类型的堆空间、以及任务队列。（后端有个 MQ，消息队列）**

**简单的理解栈空间和堆空间**

简单的说下 栈空间和 堆空间吧，因为 JavaScript 这玩意，是脚本语言，脚本语言没有太多弯弯绕的，开箱即用，我见即我得。

![preview](index.assets/v2-c557d76e62192a7e0eb94a0af3d88633_r.jpg)



> JavaScript 在创建执行上下文的时候，会创建一个叫  **变量对象** 的东西，用于保存变量的初始化。
>
> 其实在 JavaScript 的内存空间，很多参考资料，都说栈的概念不太明显，因为你比如 红宝石书中，我记得就明确指出，变量的初始化值是放在变量对象上。但是也有相关资料，说的，其实变量对象是保存在栈空间。这点就不过多细究了。大致意思就是：
>
> **简单的数据类型的数据，可以直接保存在栈空间，也就是变量对象身上。**
>
> **而复杂的数据类型，比如 数组、对象、函数、集合等包含多个数据值的类型，是存放到堆空间，由栈空间保存堆空间的内存地址，通过类似 C语言中的指针操作，由栈空间指向堆空间。或者说，栈空间，引用堆空间中的数据。**
>
> **JS 引擎工作的时候，就是通过访问上下文栈，来依此加载到主线程，进行执行。**

### 三、深浅拷贝与堆栈空间

> 然后，说回深浅拷贝。
>
> 深浅拷贝的本质，其实就是：
>
> - **浅拷贝直接复制整个变量对象身上的值，包含，指向堆空间的内存地址**
> - **深拷贝，则直接拷贝堆空间的值，并且生产新的内存地址，存放在栈（变量对象中）**

### 四、深浅拷贝的方法

**（1）浅拷贝**

- 使用 ES6 提供的 `Object.assign()` ，将所有可枚举的属性值从一个或者多个源对象赋值到目标对象，然后返回目标对象。
- 使用展开运算符 `...`  展开一个对象

```js
let obj = {
    a: '1',
    b: '2',
    c: '3'
}

let cobj = {...obj}
```

- 数组的浅拷贝 `array.slice(start, end)` 和 `Array.prototype.concat()` ，其实这两个方法也是由争议的，因为他们第一层是深拷贝，但是后面都是复制引用关系。**其实就是，只能修改到指定的数据，其它数据都是直接拷贝引用。**

**（2）深拷贝 **

- 利用 `JSON.stringify` 和 `JSON.parse` ；先把 对象转化成字符串，然后再把字符串转换成对象。就实现了深拷贝。=> **仅适用于 对象身上**
- 利用第三方工具库封装的方法。`jquery` 的 `extend` 和 `lodash`的 `cloneDepp`
- 然后使用 递归的方法

   

## 跨域

### 一、什么是跨域

> **当一个请求 url 的协议、域名、端口三者之间任意一个与当前页面 url 不同即为跨域。**

![image-20210506154118924](index.assets/image-20210506154118924.png)

**（1）什么是同源策略**

> **同源策略/SOP （Same origin policy）是一种约定，由 Netscape（网景）公司在1995年引入浏览器，它是浏览器最核心也是最基本的安全功能。 **
>
> **如果缺少了同源策略，浏览器很容易受到 XSS（跨站脚本攻击）、CSFR（跨站请求伪造） 等攻击。**
>
> **所谓同源是指：“ 协议+域名+端口” 三者相同，即使两个不同的域名指向同一个 IP 地址，也非同源。**

**（2）HTML 特殊标签**

`<link>` 、`<script>`、`<img>`、`<frame> ` 等这些标签具有跨域特性，可以直接访问。

 ### 二、处理跨域的方案

- **Jsonp**

- **Proxy 代理**

- **CORS （服务器端解决）**

- **Nginx 反向代理**

- **Websocket**

- **postMessage**

  ...

### 三、Jsonp

> **利用 script 标签，远程动态的加载 JS 代码**

**使用 JSonp 方法，需要前后端先相互约定，前端通过 `script` 标签请求跨域的域名，后端获取请求，返回相关回调方法。**

**示例1**

```html
<script>
function test() {
    alert('定义了一个方法,但是没有触发')
}
</script>

<!-- 利用 script 标签跨域，向跨域域名发起请求  -->
<script src="https://xierukun.com/index/kun"> </script> 

<!-- 注意了，上面的 script 请求，相当于是 后端返回一段代码给前端
     所以，test() 也是可以代参数滴，你把它看成实参调用 function test(a){} 
     => test('132')   -->
```

```php
public function kun() {
    return "test();"; // 后端接收到前端请求，返回相关内容
}
```

**此时，页面成功执行 test() 的调用方法。**

**示例 2**

> 示例2 和 示例1 类似，不同的是，前端请求 跨域 URL ，携带参数 callback
>
> **我们考古一些老的网站，你会发现，url  后面 紧跟着 callback 接着是一大堆字符串，那就可能利用了 Jsonp 来进行跨域**

```html
<script>
function test() {
    alert('定义了一个方法,但是没有触发')
}
</script>

<!-- 利用 script 标签跨域，向跨域域名发起请求  -->
<script src="https://xierukun.com/index/kun?callback=test"> </script> 
```

```php
public function kun() {
    $callback = $_GET["callback"]; // PHP 方法，获取前端 get 请求参数
    return $callback.'(123)'; // 后端接收到前端请求，返回相关内容
}
```

**示例 3**

> 示例3 利用第三方库，来实现 JSonp 请求

```html
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>、

<script>
$.ajax({
   type: "get",
    url: "https://xierukun.com/index/kun",
    dataType: "jsonp", // 注意，这里不是 JSON，而是 JSonp
    success: function (res) {
        console.log(res)
    }
});
</script>

<!-- 相当于 Jquery 帮我们自动处理了 -->

```

**注意，不管用原生还是第三方库，都需要跟后端约定好！**

###  四、CORS 

> 此方案只需要服务器设置 ，**`Access-Control-Allow-Origin` 即可** 前端无需设置。
>
> 若要带 cookie 请求，前后的都要设置

```php
header("Access-Control-Allow-Origin: *"); // * 代表允许所有请求 url
```

*翻译白话：后端配置，访问控制器允许的源，设置成 通配符，任意

### 五、代理 Proxy 

> **通过中间件来实现，浏览器有跨域限制，但是服务器没有跨域限制，所以中间件其实就是服务器。=> 服务器对数据进行了转发而已**

![image-20210506172902056](index.assets/image-20210506172902056.png)

**在 Vue 中使用 代理的方法，实现跨域**

> Vue 是现在前端炙手可热的三大框架之一。
>
> Vue 框架中解决跨域的方式是：

- 创建 `vue.config.js` 文件

```sh
touch vue.config.js
```

- 编辑 `vue.config.js` 文件

```js
module.exports = {
     
    // 开发环境配置
    devServer: {
        proxy: {
            '/': {
                target: 'https://xierukun.com/';
                changeOrigin: true;
            }
        }             
    }
}

// 相当于Vue 在所有 http 请求之前，添加了 `https://xierukun.com`
```

### 六、Nginx 反向代理

```nginx
# proxy 服务器
server {
   listen			80;
   server_name		www.a.com;
   
   location / {
   		proxy_pass 		http://www.b.com # 反向代理
   		proxy_cookie_domain www.b.com www.a.com;
   		index index.html index.htm;
   		
   		add_header Access-Control-Allow-Origin http://www.a.com;
   		add_header Access-Control-Allow-Credentials true;
   
   }
}
```

























## 性能优化

> **说起性能优化，首先第一个问题什么是性能优化？**
>
> **下面，我谈一谈个人的理解：**

**性能优化，它是一个专业名词。在生活中，我们经常讲到手机性能优化、电脑性能优化；在我们程序员的世界，我们又经常讲到，前端性能优化和后端性能优化。**

**我个人对性能优化定义的标准，理解为：节约资源，提高效率，使占有资源最小化，工作效率最大化。**

**对于我的理解，需要做好性能优化，需围绕两个角度，展开思考：时间角度和空间角度。**

**作为一名前端程序员，后端知识，也需要有一定的了解。我先快速，讲下后端的性能优化：**

- **首先，从空间的角度上：服务器的内存优化、控制I/O流；建立分布式架构，高并发，低耦合等等，这些都是性能优化的措施。提高工作的效率。**
- **从时间的角度上讲：设置服务器、数据库缓存，使用ng代理缓存，http缓存，使用redis缓存服务器，等待一系列为了减少请求次数，节约内存访问和计算时间的操作。都是性能优化。**

**然后就是，性能优化，他是一个非常大的话题。怎么说呢，性能优化，它是相对于某个问题对象来讲的，可能性能优化的对象本身也能作为性能优化的对象。**

**什么意思呢？你比如，面对带宽占有，请求访问量巨大的问题，我们推出了分布式架构，来解决性能的问题。但是，分布式架构作为一个对象，还有更细的性能优化的点。**

###  一、前端性能优化

> **言归正传，我讲下，前端当中的性能优化：**
>
> **首先，从大的方面讲，前端性能在性能优化方便，做了哪些：**
>
> **对于前端来说，其实空间都角度不会那么敏感。对于服务器来说，内存运存，是非常重要的，而对于前端来说，就没有那么明显了。**

- 浏览器的缓存策略：通过 强缓存和协商缓存等手段，缓存一些 静态资源 和 一些常用的信息，有效减少了请求次数和请求时间。
- 使用前后端分离架构：无论是动态数据还是页面路由跳转，都减少了客户端对服务端的依赖。
- 采用最新技术方案：HTML5提供的 APP Cache 和 新的全双工通讯协议（WebSocket），ES6 提供的异步编程方案，第三方框架，提供的虚拟DOM 和 diff  算法。
- 使用合理静态资源：比如 webp、svg  格式的图片，或者使用（雪碧）精灵图，利用 cdn 技术，引用相关资源。
- 通过懒加载和预加载，控制页面内容的渲染；通过节流和防抖控制事件频繁触发；通过事件委任减少事件注册和内存占有。

等等

**我认为，性能优化的问题，并没有标准答案。任何项目都存在精益求精的部分，具体问题，具体分析。**

### 二、从 URL 输入到页面渲染

> **我看了下，现在市场上，对于大多数关于性能优化的面试题，不知道是哪个大佬提供出来的标准答案。回答的点，大概有两部分，第一，从 URL输入 到前端页面渲染发生了哪些事情；第二，回答一些常用的性能优化手段（当然，我刚才已经讲到了一些大概）	**
>
> **下面我讲下，从 URL 输入到 前端页面渲染都发生了哪些事情**

- 用户在客户端输入 URL 地址，浏览器会拿到 URL 地址，发起 DNS 查找。查找规则是：优先查找本机DNS 缓存，如果本机没有，再去访问云服务商的 DNS 服务器。

- 访问 DNS，获取到 相对应域名的主机地址后，浏览器发起 http 请求。

- 请求到相对应的服务器，服务器接收到http 请求后，会和客户端建立 tcp 通道，也就我们说的 三次握手

- 在服务器确认与客户端通讯正常后，会响应 客户端的 http 请求内容

- 客户端接收 服务端过来的响应文件后，开始工作。html  文件，会被 JS 引擎渲染成 DOM 树，CSS 文件，会被 JS 引擎渲染层 层叠样式表。一般 JS 文件作为脚本，会被放置到代码底部，最后渲染。

- 响应过来的HTML 和 css 文件，加载就绪，浏览器的 GUI 线程，就开始工作了。将 DOM 和 层叠样式表结合，生成渲染树。

  

## Vue













## 临时

### WebPack 五个核心概念

> **（1）Entry：** 入口（Entry） 指示 WebPack 以哪个文件为入口作为开始打包的起点，分析构建内部依赖图。
>
> **（2）Output：** 输出（Output）指示 WebPack 打包后的资源 bundles 输出到哪里去，以及如何命名。
>
> **（3）Loader：** 加载器（Loader） 让 Webpack 能够去处理那些非 JavaScript 的文件（WebPack 只能识别 JavaScript）
>
> **（4）Plugins:**  插件 （Plugins）可以用于执行范围更广的任务，插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量等。=> 给 WebPack 插入翅膀，实现更多可能
>
> **（5）Mode:** 模式（Mode）指示 WebPack 使用相对应模式的配置。

### ES6

- let 和 const 命令
- es6 的模板字符串
- 增强的函数
- 扩展的字符串、对象、数组功能
- 解构赋值
- Symbol
- Map 和 Set
- 迭代器 和 生成器
- Promise 对象
- Proxy 对象
- async 的用法
- 类 class
- 模块化实现

### 模块化

> 我认为前端的模块化，本质就是让 某个封装的功能函数，能够像工具一样，拿来拿去，能够引入到自己的项目中，

**模块化经历的几个阶段：**

- 首先模块化最大的隐患，就是利用，当你引入某个功能函数的时候造成了全局污染。所以最早的模块化，是利用闭包构建一个私有类，通过 return 向外曝露对应的功能。

- 随着技术的发展，nodeJS 应运而生，提出了 **Common JS 规范**  => `module.exports` 和 `require`

- 然后社区又考虑到，commonJs 在 nodeJS 中是同步引入的，如果在浏览器是大文件模块引入的话，容易造成阻塞，所以推出了 **AMD 规范** ，允许异步加载模块。

- 后面又因为考虑到，AMD 的模块引入是全部引入（也就是**依赖前置**），后来以阿里为代表的一些厂商，提出了 **CMD规范**，意思就是说，当前代码环境用到的，才会被引入。也称为，**依赖就近。**

- 其实社区，后面还推出了一个 **UMD 规范**，提倡，commonJS 和 AMD 结合使用。这个没啥讲的，好像说，这个规范刚出来不久，ES官方，**就推出了 模块化API** =>  exports 和 import 。

  

### Vue

**（1）MVVM**

MVC 架构是前后端不分离，代表是 JSP

因为过于累赘，过渡依赖后端，所以推出了 MVVM 架构。M -> 模型 （数据），V -> 视图；VM -> 中间件，双向数据绑定的也可以看成是 observer ，类似于 Java 中的 servelet 接口（修改数据，动态修改内容）

**（2）双向数据绑定**、

> 双向数据绑定主要做三件事情：

- 收集依赖
- 感知变化
- 更新数据和视图

收集依赖和感知变化，我们可以利用 Object.defineProperty 方法创建一个观察者，来实现的数据侦听。

Object.defineProperty ()，方法里面 又  set 和 get 两个方法。当set 里面存入新的值的时候，get 就能拿到。set 是发布者，get 是订阅者。

在 Vue 中，给属性绑定一个动态属性 v-bind（:），就表明该数据的变化，将会被Vue  侦听。 

问题： object.defineProperty()，只能侦听对象，深层次的侦听，比如数组，还需要利用拦截器，在原生方法里面添加侦听的方法，来实现侦听。

**（3 ）虚拟DOM**

> 虚拟 DOM 就是，用 JS 描述 DOM 对象。我们可以直接通过 document 获取元素，然后给元素变量，加个中括号打印，或者 console.dir 打印，我们可以看到一个DOM 对象。其实这个就是虚拟DOM的形式。

再简单理解下 虚拟DOM，其实 DOM 的变化，可以看成是一个DOM 对象身上的加减。如果每次变化，都去渲染，频繁加减，肯定是会消耗性能的。所以，可以利用虚拟DOM把这个计算过程，用 JS 的语言记录下来 然后结合 diff 算法,，计算处需要渲染的地方。

**（4）diff 算法：**

> diff 算法是一个比较算法。用 旧的 DOM 节点 和 新的DOM 节点，进行同层级比较。如果 发现不一样，就会执行 补丁函数。通知订阅者，更新视图。

**（5）Vue 生命周期**

> Vue 生命周期主要分为 四个阶段：初始化阶段 => 挂载阶段 => 更新阶段 => 销毁阶段

- 初始化阶段，初始化事件 和生命周期，以及相关依赖注入和双向数据绑定。
- 其实再挂载阶段之前，还有一个编译阶段（找 el ，找模板），找el 绑定，如果没有找 vm.$muont；有模板加入渲染函数，没有模板则通过el 去找，编译阶段主要做的事情是：将模板通过解析器，解析成 AST （抽象语法树），然后找出静态节点，打上标记，将节点转化成字符串，生成 Vnode（虚拟节点）以及解析指令。
- 挂载阶段：把 el  和 data 进行关联。再挂载阶段的 mounted 生命周期中，我们就可以同时拿到 数据 和dom
- 更新阶段：数据发生更新，重新计算生成新的虚拟节点，打上补丁函数，（diff 算法的工作）
- 销毁阶段：自己删除自己。

**（6）组件传值**

- props 和 @ emit (事件触发)

- `provide` 和 `inject` 主要在开发高阶插件/组件库时使用。并不推荐用于普通应用程序代码中。
- `this.$parent` 访问父实例
- `this.$children` 访问子实例（数组）
- bus
- vuex

**（7）Vuex**

Vuex 主要有五种属性：state、getter、mutation、action、module

## ES6

## 面向对象

## 网络基础

## 数组方法

## WebPack

## 模块化

## 互联网安全



